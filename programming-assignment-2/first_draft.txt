1°Página :
MAC0422: Sistemas operacionais 2017/02

 Guilherme Costa Vieira               Nº USP: 9790930
 Victor Chiaradia Gramuglia Araujo    Nº USP: 9793756


2°Página :
        indices:

3°Página :
        Globals.h: Possui definições importantes que são usadas por todos os
arquivos diferentes, uint, position e rank.
        {position pos; uint laps, broken_lap, pts, tag; double time_elapsed; } rank;
        emalloc(size_t size);

4°Página :
        A pista: Uma matriz d x LANES (10) global da struct square (um mutex
junto comum unsigned int) com funções : initializeTrack(); updateTrack();
destroyTrack().
    typedef struct {
        uint pos;
        pthread_mutex_t mutex;
        } square;

5°Página :
        linked_list.h e sort.h: Possuem funções feitas para ajudar com a saida do
programa, printLap(), sort_range_array() entre outras.

6°Página :
        A simulação:
        Discretisação do movimento: Como com uma taxa de atualização de 60ms/20ms
e cada indice da matiz representa 1 metro, não é sempre que um ciclista ira se
mover, assim para contornar esse problema cada ciclista tem um contador, quando a
operção (updatePos + ((int) (velInRefreshTime(velocity, refresh)*refresh)))%refresh
retornar 0 o ciclista ira tentar se mover.

7°Página :
        Movimento: Para se mover todos os ciclistas irão fazer seus calculos em
paralelo, usando o mutex presente em cada posição da matriz para ser o único que
esta vendo sua possível nova posição. Após tomar uma posição nova ele ira liberar
o mutex da posição que ele estava. Entre as barreiras de sincronização (quando
todos já fizeram seu movimento o ciclista ira dar unlock no seu novo mutex).

8°Página:
        Pontuação: Sempre que um ciclista completar uma volta, o ciclista ira
acessar um vetor global com 4 posições que correspondem quantas voltas ele deve
ter completado para ganhar a pontuação associada aquele índice, após aumentar sua
pontuação ele ira aumentar o valor presente na posição acessada do vetor.
        Para o ganho dos 20 pontos adicionais, a thread encarregada da saída do
programa ira ver se o primeiro colocado possui certo número x de voltas a mais que
o segundo colocado e se sua pos->x é menor que a dele, se sim o primeiro ganha 20
pontos e x é incrementado.

9°Página:
        Quebra: após um ciclista quebrar ele muda a tag da sua posição ocupada
na pista para zero, ira dar unlock no mutex correspondente e ira sair do loop
principal da thread para então chamar um thread dummy cuja função é simplismente
chegar nas barreiras de sincronização.
        90km/h: A escolha de qual cilcista ira percorrer as duas ultimas voltas
a 90km/h é feita pela main(), antes que qualquer ciclista seja inicializado, para
alertar que a simulação agora sera realizada a 20ms uma variavel global é mudada.
        Fim para um ciclista: Quando um ciclista acaba a corrida ele ira chamar
uma thread dummy para que ela acesse as barreiras de sincronização.
